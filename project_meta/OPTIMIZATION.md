# Пути оптимизации приложения pdf2video

Этот документ описывает потенциальные улучшения производительности и архитектуры для перехода от MVP к высокопроизводительному инструменту.

## 1. Аппаратное ускорение (Hardware Acceleration)
**Текущее состояние:** Используется программный кодек `libx264` (нагрузка на CPU).
**Решение:**
- Внедрить поддержку `h264_videotoolbox` для macOS (чипы Apple Silicon/Intel).
- Добавить автоопределение доступных энкодеров (`nvenc` для NVIDIA, `vaapi` для Intel/Linux).
- **Результат:** Снижение нагрузки на CPU и кратное ускорение финальной сборки.
- **Обновление:** Добавлен параметр `-quality`. 
    - Для программного кодека `libx264` он управляет `CRF` (по умолчанию 23).
    - Для `h264_videotoolbox` он управляет **битрейтом** по формуле `Quality * 100 кбит/с` (по умолчанию 75 = 7.5 Мбит/с).
    - Это позволяет сбалансировать размер файлов аппаратного кодирования при сохранении высокого качества.

## 2. Оптимизация ввода-вывода (Memory Pipes)
**Текущее состояние:** Программа пишет тысячи промежуточных PNG на диск, которые затем читает FFmpeg.
**Решение:**
- Использовать `stdin` пайпы для передачи данных изображений напрямую в процесс FFmpeg (ВЫПОЛНЕНО).
- Передавать данные в формате `rawvideo` через оперативную память (ВЫПОЛНЕНО).
- **Результат:** Полное устранение записи промежуточных PNG на диск, снижение нагрузки на SSD и прирост скорости рендеринга.

## 3. Потоковая обработка (Pipelining)
**Текущее состояние:** Линейные этапы: Рендеринг картинок -> Генерация сегментов -> Склейка.
**Решение:**
- Разделение процесса на независимые пула воркеров: `RenderPool` (CPU, все ядра) и `EncodePool` (GPU, лимит потоков).
- Связь через каналы Go.
- **ВЫПОЛНЕНО.** Результат: балансировка нагрузки и предотвращение перегрузки GPU.

## 4. Инкрементальный рендеринг и кэширование (Caching)
**Текущее состояние:** Полная пересборка видео при любом изменении.
**Решение:**
- Хэширование содержимого каждой страницы PDF.
- Сохранение отрендеренных сегментов в долгоживущий кэш.
- Если страница не изменилась — переиспользовать готовый сегмент из кэша.
- **Результат:** Повторная сборка видео после минорных правок PDF будет занимать секунды.

## 8. Оптимизация PDF (PDF Descriptor Reuse)
**ВЫПОЛНЕНО.**
- Внедрен `sync.Pool` для хранения и переиспользования открытых дескрипторов PDF-файлов (`*fitz.Document`).
- **Проблема:** Постоянное открытие/закрытие PDF на каждую страницу создавало огромную нагрузку на I/O и замедляло рендеринг в несколько раз на больших файлах.
- **Результат:** Кратное ускорение этапа рендеринга и снижение нагрузки на файловую систему.

## 9. Масштабируемость выражений (Expression Scaling)
**ВЫПОЛНЕНО.**
- Оптимизировано построение piecewise-выражений для FFmpeg с $O(N^2)$ до $O(N)$.
- **Проблема:** Дублирование полной формулы зума внутри каждого интервала панорамирования приводило к экспоненциальному росту длины команды на сложных сценариях (сотни ключевых кадров).
- **Результат:** Стабильная работа на сценариях любой сложности без риска переполнения буфера FFmpeg или ошибки `exit status 234`.

## 10. Обход лимитов CLI (Process Argument Limits)
**ВЫПОЛНЕНО.**
- Внедрено использование `-filter_script` и `-filter_complex_script`.
- **Проблема:** Операционные системы (macOS/Linux) имеют жесткие лимиты на длину аргументов командной строки (обычно 256КБ - 1МБ). Очень сложные фильтры Ken Burns выходили за эти рамки.
- **Результат:** Команды FFmpeg теперь всегда имеют фиксированную длину, а тяжелые фильтры передаются через временные файлы. Это обеспечивает 100% надежность при создании длинных видео-монтажей.

## 11. Режим отладки и визуализации (Debug Rendering)
**ВЫПОЛНЕНО.**
- Добавлен флаг `-debug`.
- Рамки отслеживания камеры (`Scenario Tracking`) рисуются на Go-стороне для максимальной скорости и надежности (в обход ограничений фильтра `drawbox`).
- Техническая статистика накладывается через `drawtext` с проверкой поддержки фильтра.

## 12. Адаптивный DPI (Dynamic Rendering Quality)
**ВЫПОЛНЕНО.**
- Внедрен алгоритм `calculateOptimalDPI` в оркестратор `engine.go`.
- **Проблема:** Рендеринг в фиксированном DPI (например, 300) избыточен, если целевое видео имеет разрешение 1080p или 720p. Это тратило процессорное время и оперативную память на детали, которые не видны в итоговом видео.
- **Решение:** Программа рассчитывает минимально необходимый DPI для каждой страницы PDF так, чтобы он точно соответствовал разрешению видео с учетом 50% запаса под эффекты зума (Ken Burns).
- **Результат:** Снижение времени рендеринга на **20-40%** и уменьшение потребления оперативной памяти за счет меньших буферов изображений.

## 13. Buffer Pooling (Memory Reuse)
**ВЫПОЛНЕНО.**
- Внедрен централизованный `ImagePool` в `internal/system/buffer_pool.go`.
- **Проблема:** Постоянная аллокация и освобождение больших буферов `image.RGBA` (несколько мегабайт на кадр) приводила к высокой нагрузке на Garbage Collector (GC), вызывая микро-фризы и повышенное потребление CPU/RAM.
- **Решение:** Программа переиспользует буферы изображений через `sync.Pool`. Буфер возвращается в пул сразу после того, как он был передан в FFmpeg или использован для отрисовки отладочной информации.
- **Результат:** Стабильное потребление памяти при обработке длинных видео, отсутствие скачков нагрузки на GC и повышение общей отзывчивости системы.
